#pragma kernel CSErosion
#pragma kernel CSDilation
#pragma kernel CSMerge
#pragma kernel CSBlit

#include "UnifiedVoxelStructures.hlsl"

StructuredBuffer<Point> _PointsIn;
RWStructuredBuffer<Point> _PointsOut;
RWStructuredBuffer<uint> _PointCountOut;

StructuredBuffer<Point> _NewPointsIn;
uint _NewPointCountIn;

StructuredBuffer<VoxelData> _VoxelData;
StructuredBuffer<int> _VoxelPointIndices;
StructuredBuffer<int> _VoxelHashTable;
StructuredBuffer<int> _VoxelHashChains;

uint _PointCountIn;
uint _VoxelCount;
uint _HashTableSize;
float _VoxelSize;
uint _PointsPerAxis;
int _UseRandomPlacement;
float _RandomSeed;

#define EROSION_THRESHOLD 5
#define DILATION_THRESHOLD 15

int CountNeighborsVoxelBased(int3 centerVoxel)
{
    int neighborCount = 0;
    
    [unroll]
    for (int x = -1; x <= 1; x++)
    {
        [unroll]
        for (int y = -1; y <= 1; y++)
        {
            [unroll]
            for (int z = -1; z <= 1; z++)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;
                
                int3 neighborVoxel = centerVoxel + int3(x, y, z);
                int voxelDataIndex = FindVoxelDataFast(
                    neighborVoxel, _VoxelData, _VoxelHashTable,
                    _VoxelHashChains, _HashTableSize
                );
                
                if (voxelDataIndex >= 0)
                {
                    neighborCount += _VoxelData[voxelDataIndex].pointCount;
                }
            }
        }
    }
    
    return neighborCount;
}

float rand(float2 co, float seed)
{
    return frac(sin(dot(co, float2(12.9898, 78.233)) + seed) * 43758.5453);
}

[numthreads(64, 1, 1)]
void CSErosion(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VoxelCount)
    {
        return;
    }
    
    VoxelData vd = _VoxelData[id.x];
    
    int neighborCount = CountNeighborsVoxelBased(vd.index);
    
    if (neighborCount >= EROSION_THRESHOLD)
    {
        for (int i = 0; i < vd.pointCount; i++)
        {
            int pointIndex = _VoxelPointIndices[vd.dataOffset + i];
            Point pt = _PointsIn[pointIndex];
            
            uint index;
            InterlockedAdd(_PointCountOut[0], 1, index);
            _PointsOut[index] = pt;
        }
    }
}

[numthreads(64, 1, 1)]
void CSDilation(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VoxelCount)
    {
        return;
    }
    
    VoxelData vd = _VoxelData[id.x];
    
    if (vd.pointCount < EROSION_THRESHOLD)
    {
        return;
    }
    
    int neighborCount = CountNeighborsVoxelBased(vd.index);
    
    if (neighborCount >= DILATION_THRESHOLD)
    {
        return;
    }
    
    int firstPointIdx = _VoxelPointIndices[vd.dataOffset];
    float4 baseColor = _PointsIn[firstPointIdx].color;
    
    [unroll]
    for (int x = -1; x <= 1; x++)
    {
        [unroll]
        for (int y = -1; y <= 1; y++)
        {
            [unroll]
            for (int z = -1; z <= 1; z++)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;
                
                int3 newVoxelIndex = vd.index + int3(x, y, z);
                
                if (FindVoxelDataFast(newVoxelIndex, _VoxelData, _VoxelHashTable,
                                     _VoxelHashChains, _HashTableSize) >= 0)
                {
                    continue;
                }
                
                float centerX = (newVoxelIndex.x * _VoxelSize) + (_VoxelSize / 2.0);
                float voxelMinY = newVoxelIndex.y * _VoxelSize;
                float voxelMinZ = newVoxelIndex.z * _VoxelSize;
                
                uint totalPoints = (_PointsPerAxis == 1) ? 1u : (_PointsPerAxis * _PointsPerAxis);
                
                for (uint i = 0; i < totalPoints; i++)
                {
                    Point newPoint;
                    newPoint.color = baseColor;
                    newPoint.position.x = centerX;
                    newPoint.position.w = 0.0;
                    
                    if (_UseRandomPlacement > 0)
                    {
                        uint seed = id.x * 27u + (x + 1u) * 9u + (y + 1u) * 3u + (z + 1u);
                        float r1 = rand(float2(seed, i * 2.0), _RandomSeed);
                        float r2 = rand(float2(seed, i * 2.0 + 1.0), _RandomSeed);
                        newPoint.position.y = voxelMinY + r1 * _VoxelSize;
                        newPoint.position.z = voxelMinZ + r2 * _VoxelSize;
                    }
                    else
                    {
                        if (_PointsPerAxis == 1u)
                        {
                            newPoint.position.y = voxelMinY + (_VoxelSize / 2.0);
                            newPoint.position.z = voxelMinZ + (_VoxelSize / 2.0);
                        }
                        else
                        {
                            uint y_idx = i / _PointsPerAxis;
                            uint z_idx = i % _PointsPerAxis;
                            
                            float step = _VoxelSize / (float) _PointsPerAxis;
                            float initialOffset = step / 2.0;
                            newPoint.position.y = voxelMinY + initialOffset + (step * y_idx);
                            newPoint.position.z = voxelMinZ + initialOffset + (step * z_idx);
                        }
                    }
                    
                    uint index;
                    InterlockedAdd(_PointCountOut[0], 1, index);
                    _PointsOut[index] = newPoint;
                }
            }
        }
    }
}

[numthreads(64, 1, 1)]
void CSMerge(uint3 id : SV_DispatchThreadID)
{
    uint totalPointCount = _PointCountIn + _NewPointCountIn;
    if (id.x >= totalPointCount)
    {
        return;
    }
    
    if (id.x < _PointCountIn)
    {
        _PointsOut[id.x] = _PointsIn[id.x];
    }
    else
    {
        uint newIndex = id.x - _PointCountIn;
        _PointsOut[id.x] = _NewPointsIn[newIndex];
    }
}

[numthreads(64, 1, 1)]
void CSBlit(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _PointCountIn)
    {
        return;
    }
    
    _PointsOut[id.x] = _PointsIn[id.x];
}